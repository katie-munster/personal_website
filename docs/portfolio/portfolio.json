[
  {
    "path": "portfolio/2022-03-13-binarylogisticregression/",
    "title": "Binary logistic regression",
    "description": "Binary logistic regression is used to determine the probability of two palmetto species",
    "author": [],
    "date": "2022-03-14",
    "categories": [],
    "contents": "\nOverview\nThis report explores Florida palmetto data for two species (Serenoa repens and Sabal etonia) and the differences in height, canopy length, canopy width, and green leaves for the two species. Binary logistic regression is used to determine the probability of a plant being either Serenoa repens or Sabal etonia based on predictor variables.\nData citation: Abrahamson, W.G. 2019. Survival, growth and biomass estimates of two dominant palmetto species of south-central Florida from 1981 - 2017, ongoing at 5-year intervals ver 1. Environmental Data Initiative. https://doi.org/10.6073/pasta/f2f96ec76fbbd4b9db431c79a770c4d5\n\n\nshow\n\nknitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(GGally)\nlibrary(broom)\nlibrary(jtools)\nlibrary(caret)\nlibrary(AICcmodavg)\nlibrary(patchwork)\nlibrary(cowplot)\nlibrary(kableExtra)\n\n\n\nData exploration\n\n\nshow\n\n# Read in the data:\npalmetto <- read_csv(here(\"data\",\"palmetto.csv\")) %>% \n  mutate(species_name = case_when( # Add a new column for species name\n    species == 1 ~ \"Serenoa repens\",\n    species == 2  ~ \"Sabal etonia\"))\n\n\n\n\n\nshow\n\n# Exploratory plot:\n#palmetto %>% \n#  select(height:green_lvs, species_name) %>% \n#  ggpairs(aes(color = species_name))\n\n\n\n\n\nshow\n\n# Explore trends in variables:\nplot_greenlvs_height <- ggplot(data = palmetto, aes(x = green_lvs, y = height)) +\n  geom_point(aes(color = species_name)) +\n  facet_wrap(~ species_name) +\n  theme_minimal() +\n  labs(x = \"Green leaves count\",\n       y = \"Plant height\\n(cm)\",\n       title = \"Number of green leaves vs. plant height\",\n       color = \"Species\") +\n  theme(plot.background = element_rect(fill = \"white\"),\n        panel.background = element_rect(fill = \"white\"),\n        panel.grid.major = element_line(color = \"gray58\"))\n\nplot_greenlvs_length <- ggplot(data = palmetto, aes(x = green_lvs, y = length)) +\n  geom_point(aes(color = species_name)) +\n  facet_wrap(~ species_name) +\n  theme_minimal() +\n  labs(x = \"Green leaves count\",\n       y = \"Canopy length\\n(cm)\",\n       title = \"Number of green leaves vs. canopy length\",\n       color = \"Species\") +\n  theme(plot.background = element_rect(fill = \"white\"),\n        panel.background = element_rect(fill = \"white\"),\n        panel.grid.major = element_line(color = \"gray58\"))\n\nplot_greenlvs_width <- ggplot(data = palmetto, aes(x = green_lvs, y = width)) +\n  geom_point(aes(color = species_name)) +\n  facet_wrap(~ species_name) +\n  theme_minimal() +\n  labs(x = \"Green leaves count\",\n       y = \"Canopy width\\n(cm)\",\n       title = \"Number of green leaves vs. canopy width\",\n       color = \"Species\") +\n  theme(plot.background = element_rect(fill = \"white\"),\n        panel.background = element_rect(fill = \"white\"),\n        panel.grid.major = element_line(color = \"gray58\"))\n\n# Serenoa repens tend to have more green leaves than Sabal etonia. Green leaves are likely to help classify species correctly.\n\nplot_length_width <- ggplot(data = palmetto, aes(x = length, y = width)) +\n  geom_point(aes(color = species_name)) +\n  facet_wrap(~ species_name) +\n  theme_minimal() +\n  labs(x = \"Canopy length\\n(cm)\",\n       y = \"Canopy width\\n(cm)\",\n       title = \"Canopy length vs. canopy width\",\n       color = \"Species\") +\n  theme(plot.background = element_rect(fill = \"white\"),\n        panel.background = element_rect(fill = \"white\"),\n        panel.grid.major = element_line(color = \"gray58\"))\n\nplot_length_height <- ggplot(data = palmetto, aes(x = length, y = height)) +\n  geom_point(aes(color = species_name)) +\n  facet_wrap(~ species_name) +\n  theme_minimal() +\n  labs(x = \"Canopy length\\n(cm)\",\n       y = \"Plant height\\n(cm)\",\n       title = \"Canopy length vs. plant height\",\n       color = \"Species\") +\n  theme(plot.background = element_rect(fill = \"white\"),\n        panel.background = element_rect(fill = \"white\"),\n        panel.grid.major = element_line(color = \"gray58\"))\n\n# Sabal etonia tends to have longer canopy length than Serenoa repens.\n\nplot_height_width <- ggplot(data = palmetto, aes(x = height, y = width)) +\n  geom_point(aes(color = species_name)) +\n  facet_wrap(~ species_name) +\n  theme_minimal() +\n  labs(x = \"Plant height\\n(cm)\",\n       y = \"Canopy width\\n(cm)\",\n       title = \"Plant height vs. canopy width\",\n       color = \"Species\") +\n  theme(plot.background = element_rect(fill = \"white\"),\n        panel.background = element_rect(fill = \"white\"),\n        panel.grid.major = element_line(color = \"gray58\"))\n\n# Serenoa repens tend to have taller plant height than Sabal etonia.\n\n\n\n\n\nshow\n\n# Finalized plots:\nplot_greenlvs_height / plot_greenlvs_length / plot_greenlvs_width\n\n\n\n\nFigure 1. Serenoa repens tend to have more green leaves than Sabal etonia. Because of this trend, the number of green leaves variable is more likely to help classify species correctly.\n\n\nshow\n\n# Finalized plots:\nplot_length_width / plot_length_height\n\n\n\n\nFigure 2. Sabal etonia tend to have slightly longer canopy length than Serenoa repens. Therefore, the canopy length variable may help classify species correctly.\nBinary logistic regression\n\n\nshow\n\n# Convert species to factor first\npalmetto_factor <- palmetto %>% \n  mutate(species = case_when(\n    species == 2 ~ 0, # Made Sabal etonia species 0 (reference level). Serenoa repens is species 1\n    species == 1 ~ 1)) %>% \n  mutate(species = factor(species)) %>% # Convert to factor\n  drop_na(height, length, width, green_lvs)\n\n# levels(palmetto_factor$species)\n# class(palmetto_factor$species)\n\n\n\n\n\nshow\n\n# Create model 1:\nf1 <- species ~ height + length + width + green_lvs\n\nblr1_height_length_width_greenlvs <- glm(formula = f1,\n                    data = palmetto_factor,\n                    family = 'binomial')\n\n\n\n\n\nshow\n\n# Look at the results:\n# blr1_height_length_width_greenlvs\n# summary(blr1_height_length_width_greenlvs)\n# All four variables are statistically significant.\n\nblr1_tidy <- broom::tidy(blr1_height_length_width_greenlvs)\n\n\n\n\n\nshow\n\nblr1_fitted <- blr1_height_length_width_greenlvs %>% \n  broom::augment(type.predict = 'response')\n# fitted is the probability that it is a Serenoa repens\n\n\n\n\n\nshow\n\n# Visualize model 1 outcomes:\n#effect_plot(blr1_height_length_width_greenlvs,\n#            pred = green_lvs,\n#            interval = TRUE,\n#            y.label = \"Probability of Serenoa repens\")\n# Higher green leaves values will lead to more predictions of Serenoa repens\n\n#effect_plot(blr1_height_length_width_greenlvs,\n#            pred = height,\n#            interval = TRUE,\n#            y.label = \"Probability of Serenoa repens\")\n# Higher plant height values will lead to more predictions of Serenoa repens\n\n#effect_plot(blr1_height_length_width_greenlvs,\n#            pred = length,\n#            interval = TRUE,\n#            y.label = \"Probability of Serenoa repens\")\n# Higher canopy length values will lead to more predictions of Sabal etonia\n\n#effect_plot(blr1_height_length_width_greenlvs,\n#            pred = width,\n#            interval = TRUE,\n#            y.label = \"Probability of Serenoa repens\")\n# Higher canopy width values will lead to more predictions of Sabal etonia\n\n\n\n\n\nshow\n\n# Create model 2:\nf2 <- species ~ height + width + green_lvs\n\nblr2_height_width_greenlvs <- glm(formula = f2,\n                    data = palmetto_factor,\n                    family = 'binomial')\n\n\n\n\n\nshow\n\n# Look at the results:\n#blr2_height_width_greenlvs\n#summary(blr2_height_width_greenlvs)\n# Width and green leaves variables are statistically significant, but height is not\n\nblr2_tidy <- broom::tidy(blr2_height_width_greenlvs)\n\n\n\n\n\nshow\n\nblr2_fitted <- blr2_height_width_greenlvs %>% \n  broom::augment(type.predict = 'response')\n# fitted is the probability that it is a Serenoa repens\n\n\n\n\n\nshow\n\n# Visualize model 2 outcomes:\n#effect_plot(blr2_height_width_greenlvs,\n#            pred = green_lvs,\n#            interval = TRUE,\n#            y.label = \"Probability of Serenoa repens\")\n# Higher green leaves values will lead to more predictions of Serenoa repens\n\n#effect_plot(blr2_height_width_greenlvs,\n#            pred = width,\n#            interval = TRUE,\n#            y.label = \"Probability of Serenoa repens\")\n# Higher canopy width values will lead to more predictions of Sabal etonia\n\n#effect_plot(blr2_height_width_greenlvs,\n#            pred = height,\n#            interval = TRUE,\n#            y.label = \"Probability of Serenoa repens\")\n# Plant height values do not as clearly predict species. More confusion\n\n\n\n\n\nshow\n\naic_table <- AICcmodavg::aictab(list(blr1_height_length_width_greenlvs, blr2_height_width_greenlvs))\n\nrownames(aic_table) <- c(\"Model 1 (height, length, width, green leaves)\", \"Model 2 (height, width, green leaves)\") # rename row names\n\naic_table %>% \n  kable(col.names = c(\"Model Name\",\n                      \"Number of Estimated Parameters\",\n                      \"AICc\",\n                      \"Delta AICc\",\n                      \"Model Likelihood\",\n                      \"Akaike Weights\",\n                      \"Log-likelihood\",\n                      \"Cumulative Akaike Weights\"),\n        caption = \"Model selection based on AICc\") %>% \n  kable_styling()\n\n\n\nTable 1: Model selection based on AICc\n\n\n\n\nModel Name\n\n\nNumber of Estimated Parameters\n\n\nAICc\n\n\nDelta AICc\n\n\nModel Likelihood\n\n\nAkaike Weights\n\n\nLog-likelihood\n\n\nCumulative Akaike Weights\n\n\nModel 1 (height, length, width, green leaves)\n\n\nMod1\n\n\n5\n\n\n5194.567\n\n\n0.0000\n\n\n1\n\n\n1\n\n\n-2592.281\n\n\n1\n\n\nModel 2 (height, width, green leaves)\n\n\nMod2\n\n\n4\n\n\n5987.475\n\n\n792.9086\n\n\n0\n\n\n0\n\n\n-2989.736\n\n\n1\n\n\nTable 1. Based on the AICc scores, model 1 the preferred model because model 1 has the lowest AICc score and it is lower than the competing model’s AICc score more than 2 points.\n\n\nshow\n\n# Ten-fold cross validation:\nset.seed(123)\n\nn_folds <- 10\nfolds <- rep(1:n_folds, length.out = nrow(palmetto_factor))\n\npalmetto_kfold <- palmetto_factor %>% \n  mutate(fold = sample(folds, size = n(), replace = FALSE))\n\n\n\n\n\nshow\n\n# Use prediction accuracy as metric:\npred_acc <- function(x, y) {\n  accurate <- ifelse(x == y, 1, 0)\n  return(mean(accurate, na.rm = TRUE))\n}\n\n\n\n\n\nshow\n\nresults_df <- data.frame()\n\nfor(i in 1:n_folds) {\n  kfold_test <- palmetto_kfold %>% \n    filter(fold == i)\n  kfold_train <- palmetto_kfold %>% \n    filter(fold != i)\n  \n  kfold_blr1 <- glm(f1, data = kfold_train, family = 'binomial')\n  kfold_blr2 <- glm(f2, data = kfold_train, family = 'binomial')\n  \n  kfold_pred <- kfold_test %>% \n    mutate(blr1 = predict(kfold_blr1, kfold_test, type = 'response'),\n           blr2 = predict(kfold_blr2, ., type = 'response')) %>% \n    mutate(pred1 = ifelse(blr1 > .50, 1, 0),\n           pred2 = ifelse(blr2 > .50, 1, 0))\n  kfold_accuracy <- kfold_pred %>% \n    summarize(blr1_acc = pred_acc(species, pred1),\n              blr2_acc = pred_acc(species, pred2))\n  \n  results_df <- bind_rows(results_df, kfold_accuracy)\n}\n\nresults_df %>% \n  summarize(blr1_acc = mean(blr1_acc),\n            blr2_acc = mean(blr2_acc)) %>% \n  kable(col.names = c(\"Model 1 Accuracy\",\n                      \"Model 2 Accuracy\"),\n        caption = \"Model accuracy based on cross validation\") %>% \n  kable_styling()\n\n\n\nTable 2: Model accuracy based on cross validation\n\n\nModel 1 Accuracy\n\n\nModel 2 Accuracy\n\n\n0.9170147\n\n\n0.8989171\n\n\nTable 2. Based on the cross validation, model 1 the preferred model due to its higher accuracy. The higher accuracy combined with the lower AICc score supports that model 1 is the better model.\n\n\nshow\n\nset.seed(123)\n\ntr_ctrl <- trainControl(method = 'repeatedcv', number = 10, repeats = 10)\n\n# Train the model:\nmodel1 <- train(f1, data = palmetto_factor,\n                method = 'glm', family = 'binomial',\n                trControl = tr_ctrl)\n#model1\n\nmodel2 <- train(f2, data = palmetto_factor,\n                method = 'glm', family = 'binomial',\n                trControl = tr_ctrl)\n#model2\n\n\n\n\n\nshow\n\nblr1_tidy %>% \n  kable(col.names = c(\"Regression term\",\n                      \"Estimated value\",\n                      \"Standard error\",\n                      \"T-statistic\",\n                      \"P-value\"),\n        caption = \"Binary logistic regression results for model 1\") %>% \n  kable_styling()\n\n\n\nTable 3: Binary logistic regression results for model 1\n\n\nRegression term\n\n\nEstimated value\n\n\nStandard error\n\n\nT-statistic\n\n\nP-value\n\n\n(Intercept)\n\n\n-3.2266851\n\n\n0.1420708\n\n\n-22.71180\n\n\n0\n\n\nheight\n\n\n0.0292173\n\n\n0.0023061\n\n\n12.66984\n\n\n0\n\n\nlength\n\n\n-0.0458233\n\n\n0.0018661\n\n\n-24.55600\n\n\n0\n\n\nwidth\n\n\n-0.0394434\n\n\n0.0021000\n\n\n-18.78227\n\n\n0\n\n\ngreen_lvs\n\n\n1.9084747\n\n\n0.0388634\n\n\n49.10728\n\n\n0\n\n\n\n\nshow\n\nblr2_tidy %>% \n   kable(col.names = c(\"Regression term\",\n                      \"Estimated value\",\n                      \"Standard error\",\n                      \"T-statistic\",\n                      \"P-value\"),\n        caption = \"Binary logistic regression results for model 2\") %>% \n  kable_styling()\n\n\n\nTable 4: Binary logistic regression results for model 2\n\n\nRegression term\n\n\nEstimated value\n\n\nStandard error\n\n\nT-statistic\n\n\nP-value\n\n\n(Intercept)\n\n\n-3.7677215\n\n\n0.1353136\n\n\n-27.844371\n\n\n0.0000000\n\n\nheight\n\n\n0.0029504\n\n\n0.0018811\n\n\n1.568426\n\n\n0.1167816\n\n\nwidth\n\n\n-0.0690186\n\n\n0.0017852\n\n\n-38.660633\n\n\n0.0000000\n\n\ngreen_lvs\n\n\n1.8848147\n\n\n0.0361268\n\n\n52.172204\n\n\n0.0000000\n\n\n\n\nshow\n\nblr1_fitted <- blr1_fitted %>% \n  mutate(model_classification = case_when(\n    .fitted >= .5 ~ 1,\n    .fitted < .5 ~ 0)) %>% \n  mutate(accuracy = case_when(\n    species == model_classification ~ 'Correct',\n    species != model_classification ~ 'Incorrect'\n  ))\n# fitted is the probability that it is a Serenoa repens\n\ncount_accuracy <- blr1_fitted %>% \n  group_by(species) %>% \n  count(accuracy) %>% \n  mutate(species = case_when(\n    species == 0 ~ 'Sabal etonia',\n    species == 1 ~ 'Serenoa repens'\n  )) %>% \n  mutate(percent = case_when(\n    n == 5701 ~ round(n[1]/(n[1]+n[2])*100,2),\n    n == 454 ~ round(n[2]/(n[1]+n[2])*100,2),\n    n == 5548 ~ round(5548/(5548+564)*100,2),\n    n == 564 ~ round(564/(5548+564)*100,2)\n  ))\n\ncount_accuracy %>% \n  kable(col.names = c(\"Species\",\n                      \"Accuracy\",\n                      \"Count\",\n                      \"Percentage\"),\n        caption = \"Accuracy of predictions using model 1\") %>% \n  kable_styling()\n\n\n\nTable 5: Accuracy of predictions using model 1\n\n\nSpecies\n\n\nAccuracy\n\n\nCount\n\n\nPercentage\n\n\nSabal etonia\n\n\nCorrect\n\n\n5701\n\n\n92.62\n\n\nSabal etonia\n\n\nIncorrect\n\n\n454\n\n\n7.38\n\n\nSerenoa repens\n\n\nCorrect\n\n\n5548\n\n\n90.77\n\n\nSerenoa repens\n\n\nIncorrect\n\n\n564\n\n\n9.23\n\n\nTable 5. Model 1 correctly predicted Sabal etonia species 93% of the time and correctly predicted Serenoa repens 91% of the time. Model 1, which uses plant height, canopy length, canopy width, and number of green leaves as predictor variables, is the preferred model.\n\n\n\n",
    "preview": "portfolio/2022-03-13-binarylogisticregression/binarylogisticregression_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2022-03-14T00:08:36-07:00",
    "input_file": {}
  },
  {
    "path": "portfolio/2022-03-13-clustering/",
    "title": "Agglomerative hierarchical clustering",
    "description": "Hierarchical cluster analysis (agglomerative), dendrogram, and tanglegram",
    "author": [],
    "date": "2022-03-14",
    "categories": [],
    "contents": "\nOverview\nThis report explores stream chemistry data in the Santa Barbara Coastal drainage area since 2000. Stream water samples were collected and sampled for nitrogen, phosphorus, carbon, total suspended sediments, and conductivity. Agglomerative hierarchical clustering techniques are used to analyze the water chemistry data by site.\nData citation: Santa Barbara Coastal LTER and J. Melack. 2019. SBC LTER: Land: Stream chemistry in the Santa Barbara Coastal drainage area, ongoing since 2000 ver 16. Environmental Data Initiative. https://doi.org/10.6073/pasta/67a558a24ceed9a0a5bf5e46ab841174.\n\n\nknitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(janitor)\nlibrary(NbClust)\nlibrary(cluster)\nlibrary(factoextra)\nlibrary(dendextend)\nlibrary(ggdendro)\n\n\n\nData wrangling\n\n\n# Read in the data:\nstream_chemistry <- read_csv(here(\"data\", \"sbc_lter_registered_stream_chemistry.csv\")) %>% \n  clean_names() %>% \n  na_if(-999) # convert -999 values to NA\n\n# Summarize the data per site:\nstream_chemistry_site <- stream_chemistry %>% \n  group_by(site_code) %>% \n  drop_na() %>% \n  summarize(mean_nh4_u_m = mean(nh4_u_m),\n            mean_nho3u_m = mean(no3_u_m),\n            mean_po4_u_m = mean(po4_u_m),\n            mean_tdn_u_m = mean(tdn_u_m),\n            mean_tdp_u_m = mean(tdp_u_m),\n            mean_tpc_u_m = mean(tpc_u_m),\n            mean_tpn_u_m = mean(tpn_u_m),\n            mean_tpp_u_m = mean(tpp_u_m),\n            mean_tss_mgper_liter = mean(tss_mgper_liter),\n            mean_spec_cond_u_spercm = mean(spec_cond_u_spercm))\n\n\n\n\n\n# summary(stream_chemistry_site) \n# a lot of variation in the data, so rescale the variables\n\nstream_chemistry_site_scale <- stream_chemistry_site %>% \n  select(mean_nh4_u_m:mean_spec_cond_u_spercm) %>% # keep the columns containing numeric data\n  scale()\n\n# summary(stream_chemistry_site_scale) \n# now we have mean of 0 and the range is in line with one another somewhat (about 1 or 2 on either side of the mean)\n\n\n\nHierarchical cluster analysis (agglomerative)\n\n\n# Create distance matrix:\nstream_dist <- dist(stream_chemistry_site_scale, method = 'euclidean')\n\n# Hierarchical clustering (complete linkage):\nstream_hc_complete <- hclust(stream_dist, method = 'complete')\n\n# Plot using base plot:\n# plot(stream_hc_complete, cex = 0.6, hang = -1)\n\n\n\n\n\n# Cut into three clusters:\nstream_cut_hc <- cutree(stream_hc_complete, 3)\n\n# table(stream_cut_hc, stream_chemistry_site$site_code)\n\n\n\nDendrogram\n\n\nstream_hc_complete$labels <- c(\"AB00\", \"GV01\", \"MC00\", \"MC06\", \"ON02\", \"RG01\")\nggdendrogram(stream_hc_complete, rotate = TRUE) +\n  theme_minimal() +\n  labs(x = 'Site', y = 'Height')\n\n\n\n\nFigure 1. The dendrogram, created using a complete linkage method, shows multivariate clustering for water chemistry by site.\nTanglegram\n\n\n# Rerun dendrogram using a single linkage method:\nstream_hc_single <- hclust(stream_dist, method = 'single')\nstream_hc_single$labels <- c(\"AB00\", \"GV01\", \"MC00\", \"MC06\", \"ON02\", \"RG01\")\n\n# plot(stream_hc_single, cex = 0.6, hang = -1)\n\nstream_cut_hc_single <- cutree(stream_hc_single, 3)\n\n# table(stream_cut_hc_single, stream_chemistry_site$site_code)\n\n\ndend_complete <- as.dendrogram(stream_hc_complete)\ndend_single <- as.dendrogram(stream_hc_single)\n\n# Compare cluster dendrograms:\ntanglegram(dend_complete, dend_single)\n\n\n\n\nFigure 2. The tanglegram illustrates how the different linkage (complete versus single) changes the clustering.\nResults\nSites ON02 and GV01 are clustered together based on water chemistry data.\nSites MC06, MC00, RG01, and AB00 are clustered together as well.\nComplete linkage and single linkage methods have different clustering results. With the single linkage method, site\nON02 is clustered separately from the other sites.\n\n\n\n",
    "preview": "portfolio/2022-03-13-clustering/clustering_files/figure-html5/unnamed-chunk-5-1.png",
    "last_modified": "2022-03-14T00:17:54-07:00",
    "input_file": {}
  },
  {
    "path": "portfolio/2022-03-13-pca/",
    "title": "Principal component analysis",
    "description": "PCA techniques",
    "author": [],
    "date": "2022-03-14",
    "categories": [],
    "contents": "\nOverview\nThis report explores samples of persistent organic pollutants in fish collected throughout Washington state between 2007 and 2009. The Northwest Fisheries Science Center conducted chemical lab analysis of the fish samples. Principal component analysis techniques are used to analyze the results and show relationships within the data.\nData citation: Bolton, Jennie; 02/21/2018. NOAA Fisheries Northwest Fisheries Science Center. POPs and stable isotopes in bird and forage fish tissues: Fish Persistent Organic Pollutants (https://www.webapps.nwfsc.noaa.gov/apex/parrdata/inventory/tables/table/fish_persistent_organic_pollutants)\n\n\nknitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(janitor)\nlibrary(ggfortify)\n\n\n\n\n\n# Read in the data:\nfish_pollutants <- read_csv(here(\"data\", \"fish_persistent_organic_pollutants_data.csv\")) %>% \n  clean_names()\n\n\n\nPrincipal Component Analysis (PCA)\n\n\nfish_pollutants_clean <- fish_pollutants %>% \n  select(-replicate, -ad_clipped, -samplenote) %>%  # remove these columns because mostly only NA data\n  drop_na() # PCA can't run with NA values\n\nfish_pollutants_pca <- fish_pollutants_clean %>% \n  select(standard_length, body_mass, lipidiatro_sale_format:lipidiatro_pl_format) %>% # PCA can only handle numeric data and focusing on a few pollutants\n  rename(length_mm = standard_length,\n         mass_g = body_mass,\n         lipid_sale = lipidiatro_sale_format,\n         lipid_tg = lipidiatro_tg_format,\n         lipid_ffa = lipidiatro_ffa_format,\n         lipid_chol = lipidiatro_chol_format,\n         lipid_pl = lipidiatro_pl_format) %>% \n  scale() %>% \n  prcomp()\n\n\n\nBiplot\n\n\nautoplot(fish_pollutants_pca,\n         data = fish_pollutants_clean, \n         loadings = TRUE,\n         colour = 'species',\n         loadings.label = TRUE,\n         loadings.colour = 'black',\n         loadings.label.colour = 'black',\n         loadings.label.vjust = -.5) +\n  scale_color_manual(values = c('red', 'orange', 'green', 'blue', 'purple', 'pink', 'gray')) +\n  theme_minimal() +\n  labs(title = \"Principal Components Analysis\",\n       color = \"Species\")\n\n\n\n\nFigure 1. The biplot illustrates correlation between variables. There is strong correlation between fish length (mm) and fish body mass (g) as illustrated by the small angle between the corresponding arrows. As well, the points tend to be grouped by species.\nScreeplot\n\n\nsd_vec <- fish_pollutants_pca$sdev\nvar_vec <- sd_vec^2\n\npc_names <- colnames(fish_pollutants_pca$rotation)\npct_expl_df <- data.frame(v = var_vec,\n                          pct_v = var_vec / sum(var_vec),\n                          pc = fct_inorder(pc_names)) %>% \n  mutate(pct_lbl = paste0(round(pct_v * 100, 1), '%'))\n\nggplot(pct_expl_df, aes(x = pc, y = v)) +\n  geom_col(aes(fill = pc)) +\n  geom_text(aes(label = pct_lbl), vjust = 0, nudge_y = .005) +\n  scale_fill_manual(values = c(\"PC1\" = \"darkslategray\",\n                               \"PC2\" = \"darkslategray4\",\n                               \"PC3\" = \"darkslategray3\",\n                               \"PC4\" = \"darkslategray2\",\n                               \"PC5\" = \"darkslategray1\",\n                               \"PC6\" = \"azure2\",\n                               \"PC7\" = \"aliceblue\")) +\n  labs(x = 'Principal component', y = 'Variance explained', fill = \"Principal component\") +\n  theme_minimal()\n\n\n\n\nFigure 2. The screeplot shows that the first three principal components capture 83.9% of the variance. As such, it would be reasonable to drop PC4, PC5, PC6, and PC7.\nResults\nData points tend to be grouped by species.\nThere is high correlation between fish length (mm) and fish body mass (g).\nThere is negative correlation between FFA lipid values (% of total lipid) and TG lipid values (% of total lipid) as well as negative correlation between Chol lipid values (% of total lipid) and TG lipid values (% of total lipid).\nPrincipal components 1, 2, and 3 capture about 84% of the variance. It is recommended to drop the other principal components.\n\n\n\n",
    "preview": "portfolio/2022-03-13-pca/pca_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2022-03-14T00:13:56-07:00",
    "input_file": {}
  },
  {
    "path": "portfolio/2022-03-13-dataviz/",
    "title": "Data visualization",
    "description": "Data visualizations using ggplot",
    "author": [],
    "date": "2022-03-13",
    "categories": [],
    "contents": "\nOverview\nThis report explores the counts of mountain yellow-legged frog (Rana muscosa) observed in the Sierra Nevada aquatic ecosystems. Amphibian abundance data were recorded by the Sierra Lakes Inventory Project from 1995-2002.\nData citation: Knapp, R.A., C. Pavelka, E.E. Hegeman, and T.C. Smith. 2020. The Sierra Lakes Inventory Project: Non-Native fish and community composition of lakes and ponds in the Sierra Nevada, California ver 2. Environmental Data Initiative. https://doi.org/10.6073/pasta/d835832d7fd00d9e4466e44eea87fab3.\n\n\nshow\n\nknitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(patchwork)\nlibrary(cowplot)\nlibrary(lubridate)\n\n\n\n\n\nshow\n\n# Read in the data:\nsierra_amphibians <- readxl::read_excel(here('data', 'sierra_amphibians.xlsx'))\n\n\n\n\n\nshow\n\n# Clean the data to filter for adult, subadult, and tadpole Rana muscosa frogs.\nrana_muscosa <- sierra_amphibians %>% \n  mutate(survey_date = ymd(survey_date)) %>% # convert the date to date format. Checked this with str(rana_muscosa$survey_date) in the console.\n  mutate(year = year(survey_date)) %>% # create a column that only contains the year\n  filter(amphibian_species == \"RAMU\") %>% # filter only for Rana muscosa species\n  filter(amphibian_life_stage %in% c(\"SubAdult\", \"Tadpole\", \"Adult\")) %>%  # exclude 'EggMass' level\n  drop_na(amphibian_number)\n\n\n\n\n\nshow\n\n# Calculate the total observations of Rana muscosa frogs each year\nrana_muscosa_counts <- rana_muscosa %>% \n  group_by(amphibian_life_stage, year) %>% # Categorize the data by life stage and year\n  summarize(rana_muscosa_count = sum(amphibian_number))\n\n\n\nData visualizations\n\n\nshow\n\nplot1 <- ggplot(data = rana_muscosa_counts, aes(x = as.factor(year), y = rana_muscosa_count)) +\n  geom_col(aes(fill = amphibian_life_stage)) +\n  theme_minimal() +\n  labs(x = \"Survey year\",\n       y = \"Count\",\n       title = \"Counts of mountain yellow-legged frogs (Rana muscosa)\",\n       fill = \"Amphibian life stage\") +\n  scale_fill_manual(values = c(\"Tadpole\" = \"darkolivegreen1\",\n                               \"SubAdult\" = \"darkolivegreen3\",\n                               \"Adult\" = \"darkolivegreen\"),\n                    limits = c(\"Tadpole\", \"SubAdult\", \"Adult\")) +\n  theme(plot.background = element_rect(fill = \"white\"),\n        panel.background = element_rect(fill = \"white\"),\n        panel.grid.major = element_line(color = \"gray58\"))\n\nplot1\n\n\n\n\nFigure 1. The count of mountain yellow-legged frog (Rana muscosa) in the Sierra Nevada aquatic ecosystems from the years 1995-2002. The counts are categorized by amphibian life stage (tadpole, subadult, or adult).\n\n\nshow\n\n# Clean the data to filter for adult and subadult Rana muscosa frogs\nrana_muscosa_by_lake <- sierra_amphibians %>% \n  mutate(survey_date = ymd(survey_date)) %>% # convert the date to date format\n  mutate(year = year(survey_date)) %>% # create a column that only contains the year\n  filter(amphibian_species == \"RAMU\") %>% # filter only for Rana muscosa species\n  filter(amphibian_life_stage %in% c(\"SubAdult\", \"Adult\")) # exclude 'EggMass' and 'Tadpole' levels\n  \nrana_muscosa_by_lake$lake_id <- sub(\"^\", \"Lake \", rana_muscosa_by_lake$lake_id) # update lake_id column to add a label\n\n\n\n\n\nshow\n\n# Calculate the total observations of Rana muscosa frogs at each lake and determine the top five lakes with the greatest total observed counts\nrana_muscosa_by_lake_counts <- rana_muscosa_by_lake %>% \n  group_by(lake_id) %>% # Categorize the data by lake_id\n  summarize(rana_muscosa_count = sum(amphibian_number)) %>% \n  slice_max(rana_muscosa_count, n = 5) %>% \n  arrange(desc(rana_muscosa_count))\n\n\n\n\n\nshow\n\nplot2 <- ggplot(data = rana_muscosa_by_lake_counts, aes(x = fct_reorder(lake_id, -rana_muscosa_count), y = rana_muscosa_count)) +\n  geom_col(aes(fill = -rana_muscosa_count)) +\n  theme_minimal() +\n  labs(x = \"Lake ID\",\n       y = \"Count (adult + subadult)\",\n       title = \"Greatest observed counts of mountain yellow-legged frogs (Rana muscosa)\",\n       fill = \"Total observed counts\") +\n  theme(plot.background = element_rect(fill = \"white\"),\n        panel.background = element_rect(fill = \"white\"),\n        panel.grid.major = element_line(color = \"gray58\"))\n\nplot2\n\n\n\n\nFigure 2. The top five Sierra Nevada lakes with the greatest total observed counts of mountain yellow-legged frog (Rana muscosa) for the years 1995-2002.\n\n\nshow\n\n# Combine the two graphs into a single compound figure\nplot1 / plot2\n\n\n\n\nFigure 3. From 1995 to 2002, the observed counts of mountain yellow-legged frogs (Rana muscosa) in the tadpole life stage increased and the majority of observations were tadpoles, as compared to subadults and adults. Further analysis illustrates the top 5 lakes with the greatest total observed counts of subadult and adult mountain yellow-legged frogs recorded from 1995 to 2002.\n\n\n\n",
    "preview": "portfolio/2022-03-13-dataviz/dataviz_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2022-03-13T23:41:05-07:00",
    "input_file": {}
  },
  {
    "path": "portfolio/2022-03-13-modelselection/",
    "title": "Model selection",
    "description": "Multiple linear regression models",
    "author": [],
    "date": "2022-03-13",
    "categories": [],
    "contents": "\nOverview\nThis report explores the relationship between oxygen saturation of seawater off California’s coast and water temperature, salinity, phosphate concentration, and depth. Data were recorded by California Cooperative Oceanic Fisheries Investigations (CalCOFI) since 1949. The data is available online in the CalCOFI Hydrographic Database.\nData citation: CalCOFI data are available for use without restriction. Data downloaded from https://calcofi.org/ccdata.html. Accessed 1/10/2022.\n\n\nknitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(kableExtra)\n\n\n\nData wrangling\nRead in the data.\n\n\n# Read in data:\nseawater_samples <- read_csv(here(\"data\", \"calcofi_seawater_samples.csv\"))\n\n\n\nMultiple linear regression models\n\n\n# Create two multiple linear regression models:\nf1 <- o2sat ~ t_deg_c + salinity + po4u_m\nmdl1 <- lm(f1, data = seawater_samples)\n\nf2 <- o2sat ~ t_deg_c + salinity + po4u_m + depth_m\nmdl2 <- lm(f2, data = seawater_samples)\n\n\n\nUse AIC to select the better model\n\n\n# Use AIC to compare:\naic_table <- AICcmodavg::aictab(list(mdl1, mdl2))\n# Model 2 is the preferred model\n\nrownames(aic_table) <- c(\"Model 2\", \"Model 1\") # rename row names\n\naic_table %>% \n  kable(col.names = c(\"Model Name\",\n                      \"Number of Estimated Parameters\",\n                      \"AICc\",\n                      \"Delta AICc\",\n                      \"Model Likelihood\",\n                      \"Akaike Weights\",\n                      \"Log-likelihood\",\n                      \"Cumulative Akaike Weights\"),\n        caption = \"Model selection based on AICc\") %>% \n  kable_styling()\n\n\n\nTable 1: Model selection based on AICc\n\n\n\n\nModel Name\n\n\nNumber of Estimated Parameters\n\n\nAICc\n\n\nDelta AICc\n\n\nModel Likelihood\n\n\nAkaike Weights\n\n\nLog-likelihood\n\n\nCumulative Akaike Weights\n\n\nModel 2\n\n\nMod2\n\n\n6\n\n\n616.6048\n\n\n0.000000\n\n\n1.0000000\n\n\n0.7703216\n\n\n-301.8508\n\n\n0.7703216\n\n\nModel 1\n\n\nMod1\n\n\n5\n\n\n619.0251\n\n\n2.420256\n\n\n0.2981592\n\n\n0.2296784\n\n\n-304.1934\n\n\n1.0000000\n\n\nTable 1. Based on the AICc scores, model 2 the preferred model because model 2 has the lowest AICc score and it is lower than the competing model’s AICc score by at least 2 points.\nPerform a 10-fold cross validation on the two models, using root-mean-square error as the scoring method\n\n\n# K-fold cross validation:\nfolds <- 10\nfold_vec <- rep(1:folds, length.out = nrow(seawater_samples)) # repeat through each row until it gets through all 100 observations\ntable(fold_vec)\n\n\nfold_vec\n 1  2  3  4  5  6  7  8  9 10 \n10 10 10 10 10 10 10 10 10 10 \n\nset.seed(123) # so we can get the same random numbers again\n\nseawater_fold <- seawater_samples %>% \n  mutate(group = sample(fold_vec, size = n(), replace = FALSE))\n\n# First fold:\ntest_df <- seawater_fold %>% \n  filter(group ==1)\ntrain_df <- seawater_fold %>% \n  filter(group != 1)\n\n\n\n\n\n# Create the root-mean-square-error function\ncalc_rmse <- function(x, y) {\n  rmse_result <- (x - y)^2 %>% mean() %>% sqrt()\n  return(rmse_result)\n}\n\n\n\n\n\n# Use the training dataset to create linear regression models\ntraining_mdl1 <- lm(f1, data = train_df)\n\ntraining_mdl2 <- lm(f2, data = train_df)\n\n\n\n\n\n# Use the trained models to predict on test data\npredict_test <- test_df %>% \n  mutate(model1 = predict(training_mdl1, test_df),\n         model2 = predict(training_mdl2, test_df))\n\nrmse_predict_test <- predict_test %>% \n  summarize(rmse_mdl1 = calc_rmse(model1, o2sat),\n            rmse_mdl2 = calc_rmse(model2, o2sat))\n\nrmse_predict_test # Model 2 is performing best\n\n\n# A tibble: 1 × 2\n  rmse_mdl1 rmse_mdl2\n      <dbl>     <dbl>\n1      8.92      8.44\n\n\n\n# Loop over all 10 folds and average the results\nrmse_df <- data.frame()\n\nn_iterations <- 5\n\nfor(j in 1:n_iterations) {\n  for(i in 1:folds) {\n    kfold_test_df <- seawater_fold %>% \n      filter(group == i)\n    kfold_train_df <- seawater_fold %>% \n      filter(group != i)\n    kfold_mdl1 <- lm(f1, data = kfold_train_df)\n    kfold_mdl2 <- lm(f2, data = kfold_train_df)\n    \n    kfold_pred_df <- kfold_test_df %>% \n      mutate(mdl1 = predict(kfold_mdl1, kfold_test_df),\n             mdl2 = predict(kfold_mdl2, .))\n    kfold_rmse <- kfold_pred_df %>% \n      summarize(rmse_mdl1 = calc_rmse(mdl1, o2sat),\n                rmse_mdl2 = calc_rmse(mdl2, o2sat))\n    \n    rmse_df <- bind_rows(rmse_df, kfold_rmse)\n  }\n}\n\nrmse_summary <- rmse_df %>% \n  summarize(mean_rmse_mdl1 = mean(rmse_mdl1),\n            mean_rmse_mdl2 = mean(rmse_mdl2))\n# Model 2 looks like the best model again\n\nrmse_summary %>% \n  kable(col.names = c(\"Model 1 Mean RMSE\",\n                      \"Model 2 Mean RMSE\"),\n        caption = \"Average RMSE values across all 10 folds\") %>% \n  kable_styling()\n\n\n\nTable 2: Average RMSE values across all 10 folds\n\n\nModel 1 Mean RMSE\n\n\nModel 2 Mean RMSE\n\n\n5.040278\n\n\n4.949908\n\n\nTable 2. Based on the average RMSE values resulting from a 10-fold cross validation, model 2 is the better model. Model 2 has a lower mean RMSE value than model 1.\nFinal model\nBased on the above analysis of AICc scores and average RMSE values, model 2 is the preferred model.\n\n\n# Final model:\nfinal_mdl <- lm(f2, data = seawater_samples)\nsummary(final_mdl)\n\n\n\nCall:\nlm(formula = f2, data = seawater_samples)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-26.3023  -2.2828  -0.2479   2.1771  19.4459 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 144.06686   95.36730   1.511   0.1342    \nt_deg_c      -0.74981    0.40494  -1.852   0.0672 .  \nsalinity     -0.43945    2.98897  -0.147   0.8834    \npo4u_m      -37.71159    2.50113 -15.078   <2e-16 ***\ndepth_m      -0.03196    0.01497  -2.135   0.0354 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 5.08 on 95 degrees of freedom\nMultiple R-squared:  0.9574,    Adjusted R-squared:  0.9557 \nF-statistic: 534.3 on 4 and 95 DF,  p-value: < 2.2e-16\n\nFinal parameterized model:\n\\[\n\\begin{aligned}\n\\operatorname{\\widehat{o2sat}} &= 144.07 - 0.75(\\operatorname{t\\_deg\\_c}) - 0.44(\\operatorname{salinity}) - 37.71(\\operatorname{po4u\\_m})\\ - \\\\\n&\\quad 0.03(\\operatorname{depth\\_m})\n\\end{aligned}\n\\]\n\n\n\n",
    "preview": {},
    "last_modified": "2022-03-13T23:40:13-07:00",
    "input_file": {}
  }
]
